# 시간표 자동화: 정리 + 데이터 확보 방안

## 1. 정리

- **매칭**: 우리가 **이미 가진** 시간표 데이터(TIMETABLE_DB)로 move 항목의 `desc`(예: 하카타역 → 구마모토역)와 매칭해서 자동으로 시간표 붙이는 건 **가능**하다.
- **가져오기**: 일본 전철/버스의 **실시간·상세 시간표를 외부에서 자동으로 가져오는 것**은 **어렵다**. 무료 공개 API가 거의 없고, 있어도 “경로 검색”(소요시간·요금) 위주지 “열차별 출발시각 리스트”를 주진 않는다.
- 따라서 **“데이터를 우리가 확보해 두고, 그걸로 매칭”**하는 구조가 현실적이다.  
  → **시간표 데이터를 어떻게 확보할지** 방안을 따로 짜야 한다.

---

## 2. 시간표 데이터 확보 방안

### A. 수동 정리 확장 (현재 방식 유지)

- **내용**: `src/data/timetable.js`의 TIMETABLE_DB에 구간을 하나씩 추가.  
  오사카·도쿄·교토 등 필요한 노선을 홈페이지/안내 PDF/현지 확인으로 정리해 JSON 형태로 넣는다.
- **장점**: 비용 없음, 정확도·품질 통제 가능, 앱에서 그대로 매칭에 쓸 수 있음.
- **단점**: 구간마다 수작업, 노선/시즌 변경 시 수동 갱신 필요.

### B. 공개 데이터·오픈소스 수집

- **GTFS(General Transit Feed Specification)**: 일부 교통기관이 공개. 일본에서도 일부 지자체/사철이 GTFS를 제공하는 경우가 있음.  
  → GTFS 파싱해서 “노선·정거장·출발시각” 형태로 가공하면 우리 TIMETABLE_DB와 비슷한 구조로 넣을 수 있음.
- **일본 오픈 데이터**: 정부/지자체 오픈데이터, GitHub 등에 올라온 정적 다이어가 있을 수 있음.  
  → 라이선스·갱신 주기 확인 후, 우리 포맷으로 변환해 DB에 반영.
- **장점**: 무료·재사용 가능한 경우 많음.  
- **단점**: 구간·노선 커버리지 제한적, 포맷 변환·정제 작업 필요.

### C. 유료 API

- **Jorudan Biz API**, **NAVITIME** 등: 경로·시간표 검색 API 제공.  
  → “출발역·도착역·시간대”로 요청하면 해당 시간대 열차/버스 목록을 받을 수 있음.
- **장점**: 전국·실시간에 가깝게, 다양한 노선 커버.  
- **단점**: 비용·가입·할당량 관리 필요.

### D. 스크래핑

- 역/버스 회사 홈페이지에서 시간표를 크롤링해 우리 포맷으로 저장.
- **단점**: 이용약관·저작권·접근 차단·구조 변경 리스크. **권장하지 않음** (법적 검토 없이 사용 시 위험).

---

## 3. 제안 로드맵

1. **1단계 (우선)**  
   - **매칭 로직** 구현: move 항목의 `desc` 파싱 → TIMETABLE_DB와 매칭 → 일치하면 `detail.timetable` 자동 부여.  
   - **데이터**: 지금 있는 TIMETABLE_DB만으로도 “매칭이 된다”는 걸 확인.
2. **2단계**  
   - **수동 확장**: 자주 쓰는 구간(오사카·도쿄·교토 등)을 하나씩 TIMETABLE_DB에 추가.  
   - 필요하면 “데이터 추가 가이드”(필드 설명, 예시 1~2개)를 문서로 정리.
3. **3단계 (선택)**  
   - **공개 데이터**: 사용하려는 지역의 GTFS/오픈데이터가 있는지 조사 → 있으면 파싱·가공 파이프라인 설계(스크립트로 JSON 생성 → TIMETABLE_DB 또는 별도 테이블에 적재).  
   - **유료 API**: 예산·요구사항이 맞으면 “실시간 검색”용으로만 쓰고, 결과를 캐시하거나 우리 포맷으로 저장해 두는 방식 검토.

이렇게 하면 “가져오는 건 어렵지만, 가져온(또는 수동으로 넣은) 데이터로 매칭은 확실히 가능”하고, **데이터 확보 방안**도 단계별로 짜 둔 상태가 된다.

---

## 4. 전국 타임테이블 DB를 "다 가져오는" 방법

**목표**: 웬만한 전국 노선을 TIMETABLE_DB(또는 동등한 저장소)에 갖춰 두고, 교통(move) 일정에서 검색·선택해 쓸 수 있게 하는 것.

### 4.1 단계별 접근

| 단계 | 내용 | 산출물 |
|------|------|--------|
| **1. 수동 확장** | 자주 쓰는 구간(오사카·도쿄·교토·후쿠오카 등)을 하나씩 `timetable.js`에 추가. | TIMETABLE_DB 항목 수 점진적 증가. |
| **2. 데이터 가이드** | 새 노선 추가 시 필드·형식·예시를 `docs/timetable-data-guide.md`에 정리. | 동일 포맷 유지, 협업·추가 작업 용이. |
| **3. GTFS 조사·파이프라인** | 일본 GTFS 공개처(지자체·사철·오픈데이터) 조사 → GTFS 파싱 스크립트 작성 → 우리 포맷(노선·정거장·출발시각)으로 JSON 생성. | `scripts/` 아래 스크립트, 생성된 JSON을 TIMETABLE_DB에 병합 또는 별도 테이블 적재. |
| **4. (선택) 유료 API** | Jorudan Biz, NAVITIME 등으로 "출발역·도착역·시간" 검색 → 받은 결과를 우리 포맷으로 변환해 캐시/DB에 저장. | 실시간에 가까운 전국 커버리지. |

### 4.2 GTFS 파이프라인 (구체화 시)

1. **GTFS 소스 확보**: 일본 내 GTFS 공개 데이터(Transitland, 개별 교통기관 등) 수집.
2. **스크립트**: GTFS `routes.txt`, `trips.txt`, `stop_times.txt` 등 파싱 → 노선별·구간별로 "출발역 → 도착역" + 시간 리스트 형태로 변환.
3. **출력**: `timetable.js`와 같은 구조의 JSON 또는 SQL 시드 → 기존 TIMETABLE_DB와 병합하거나, 앱에서 "원본 DB + GTFS 유래 데이터"를 함께 검색하도록 연동.

### 4.3 UX와의 관계

- 교통(move) 일정에서는 **드롭다운이 아니라 "시간표 불러오기" → 검색**으로 노선을 고르게 함.
- DB에 노선이 많을수록 검색으로 원하는 구간을 빠르게 찾기 쉬우므로, **전국 DB 확보**와 **시간표 검색 UX**는 함께 가져가면 된다.
