# TravelUNU — Playwright E2E 테스트 시나리오

> 작성일: 2026.02.15
> 대상: localhost dev 서버
> 도구: Playwright MCP
> 인증: Supabase OAuth → storageState 재사용

---

## 0. 테스트 환경 설정

### 0-1. 인증 (storageState 방식)

Supabase는 Kakao OAuth만 지원 → Playwright에서 OAuth 자동화 어려움.
**storageState 파일을 미리 만들어 재사용.**

```
# 1회 수동 준비:
# 1) 브라우저에서 로그인
# 2) DevTools → Application → Local Storage → sb-xxx-auth-token 값 확인
# 3) storageState 파일로 저장

# User A: tests/auth/user-a.json
# User B: tests/auth/user-b.json  (동시편집용 별도 계정)
```

**Playwright 설정:**
```javascript
// playwright.config.js
{
  use: {
    baseURL: 'http://localhost:5173',
    storageState: 'tests/auth/user-a.json',
  },
  projects: [
    { name: 'user-a', use: { storageState: 'tests/auth/user-a.json' } },
    { name: 'user-b', use: { storageState: 'tests/auth/user-b.json' } },
  ]
}
```

### 0-2. 테스트 데이터 전략

| 전략 | 방법 |
|------|------|
| **여행 생성** | 각 테스트 스위트 시작 시 CreateTripWizard로 신규 여행 생성 |
| **클린업** | afterAll에서 생성한 여행 삭제 (또는 Supabase API 직접 호출) |
| **격리** | 테스트별 고유 여행명 (타임스탬프 포함) → 서로 간섭 방지 |
| **동시편집** | User A가 여행 생성 → 공유 코드 → User B가 join → 두 브라우저 동시 조작 |

### 0-3. 공통 유틸리티 함수 (추천)

```javascript
// tests/helpers.js

/** 여행 생성 → 플래너 페이지 진입 */
async function createTripAndNavigate(page, name, destinations, dates) { ... }

/** 현재 Day의 아이템 목록 텍스트 가져오기 */
async function getItemTexts(page) { ... }

/** 특정 Day 탭 클릭 */
async function selectDay(page, dayIndex) { ... }

/** 아이템 추가 (직접 입력) */
async function addItemManually(page, time, type, desc) { ... }

/** 토스트 메시지 확인 */
async function expectToast(page, text) { ... }

/** 공유 코드 가져오기 */
async function getShareCode(page) { ... }
```

---

## 1. Trip 관리 (HomePage)

### T-01. 여행 생성 — 기본 플로우

```
전제: 로그인 상태, HomePage
단계:
  1. "여행 만들기" 버튼 클릭
  2. Step 1: 여행 이름 입력 ("테스트 여행 {timestamp}")
  3. 여행지 입력 ("도쿄") → 추가
  4. "다음" 클릭
  5. Step 2: 날짜 선택 (3박 4일)
  6. "다음" 클릭
  7. Step 3: "건너뛰기" 선택 (AI 생성 없이)
검증:
  - /trip/{tripId} 로 이동됨
  - Day 1 ~ Day 4 탭 존재
  - 각 Day에 오전/오후/저녁 섹션 표시
```

### T-02. 여행 생성 — AI 일정 생성

```
전제: 로그인 상태, HomePage
단계:
  1. "여행 만들기" 버튼 클릭
  2. Step 1: 이름 "AI 테스트", 여행지 "오사카"
  3. Step 2: 날짜 2박 3일
  4. Step 3: "AI로 일정 만들기" 선택
  5. 취향 입력 (또는 기본값)
  6. 생성 대기 (로딩 표시 확인)
검증:
  - 각 Day에 아이템이 채워져 있음
  - 아이템에 시간, 이름, 유형(food/spot/move 등) 존재
  - 일부 아이템에 이미지/평점 표시 (RAG 매칭)
  - 토스트 "일정이 생성되었습니다" 또는 유사 메시지
주의:
  - AI 응답 시간 ~2분 → timeout 150초 이상 필요
  - Gemini API 호출 발생 → rate limit 고려
```

### T-03. 여행 수정 (이름/날짜)

```
전제: 여행 존재
단계:
  1. HomePage에서 해당 여행의 메뉴 (⋮) 클릭
  2. "수정" 선택
  3. 이름 변경 → 저장
검증:
  - HomePage 목록에 변경된 이름 표시
```

### T-04. 여행 삭제

```
전제: 여행 존재
단계:
  1. HomePage에서 해당 여행 메뉴 → "삭제"
  2. 확인 다이얼로그 → "삭제" 클릭
검증:
  - 목록에서 해당 여행 사라짐
  - /trip/{tripId} 접근 시 리다이렉트 또는 에러
```

### T-05. 여행 복제

```
전제: 아이템이 있는 여행 존재
단계:
  1. HomePage에서 해당 여행 메뉴 → "복제"
검증:
  - 새 여행이 목록에 추가됨 (이름에 "복사본" 등)
  - 원본과 동일한 일정 구조
```

### T-06. 여행 공유 코드 생성

```
전제: 여행 존재
단계:
  1. 여행 메뉴 → "여행 공유"
검증:
  - 공유 링크 복사됨 (클립보드)
  - 토스트 "공유 링크가 복사되었습니다"
```

---

## 2. Day 관리

### D-01. Day 추가

```
전제: 여행 플래너 열림 (4일 여행)
단계:
  1. "날짜 추가" 버튼 클릭
  2. (라벨 입력 또는 기본값)
  3. 확인
검증:
  - Day 5 탭 추가됨
  - Day 5에 오전/오후/저녁 빈 섹션
  - 자동으로 Day 5 선택됨
  - 토스트 "Day 5 추가 완료"
```

### D-02. Day 삭제

```
전제: Day 5까지 존재
단계:
  1. Day 5 선택
  2. Day 삭제 버튼 클릭
  3. 확인 다이얼로그 → "삭제"
검증:
  - Day 5 탭 사라짐
  - 토스트에 "복구" 액션 표시
  - Day 4가 선택됨
```

### D-03. Day 삭제 후 복구 (Undo)

```
전제: D-02 직후
단계:
  1. 토스트의 "복구" 버튼 클릭
검증:
  - Day 5 탭 다시 나타남
  - Day 5의 아이템이 삭제 전과 동일
  - 토스트 "복구했어요"
```

### D-04. Day 이름 변경

```
전제: 여행 플래너 열림
단계:
  1. Day 탭 길게 누르기 또는 편집 모드 진입
  2. 이름 입력 ("쇼핑 데이")
  3. 저장
검증:
  - Day 탭에 "쇼핑 데이" 표시
  - 토스트 "날짜 이름이 변경되었습니다"
```

### D-05. Day 순서 변경

```
전제: Day 1~4 존재, Day 1에 아이템 A, Day 3에 아이템 B
단계:
  1. Day 순서 변경 버튼 클릭
  2. Day 3을 Day 1 위치로 드래그
  3. 확인
검증:
  - 첫 번째 탭이 이전 Day 3 (아이템 B 포함)
  - 세 번째 탭이 이전 Day 1 (아이템 A 포함)
  - 토스트 "Day 순서가 변경되었습니다"
```

### D-06. Day 삭제 시 _dayOrder 보존 (M4 수정 검증)

```
전제: Day 1~4 존재, Day 순서를 [Day3, Day1, Day2, Day4]로 변경해놓은 상태
단계:
  1. Day 2 (원래 Day1) 삭제
검증:
  - 나머지 Day 순서 유지: [Day3, Day2, Day4] (원래 순서 기준)
  - _dayOrder가 초기화되지 않음
```

### D-07. 마지막 Day 삭제 시도

```
전제: Day 1만 존재
단계:
  1. Day 1 삭제 시도
검증:
  - 삭제 안 됨
  - 토스트 "마지막 날짜는 삭제할 수 없어요"
```

---

## 3. 아이템 CRUD

### I-01. 아이템 직접 추가

```
전제: 여행 플래너 열림, Day 1 선택
단계:
  1. "일정 추가" 버튼 클릭
  2. "직접 일정 추가" 선택
  3. AddPlacePage에서: 시간 "12:00", 유형 "식사", 이름 "라멘 이치란"
  4. 저장
검증:
  - Day 1 오후 섹션에 "라멘 이치란" 카드 표시
  - 시간 "12:00" 표시
  - 카테고리 배지 "식사"
  - 토스트 "일정이 추가되었습니다"
```

### I-02. 아이템 수정 — 상세 다이얼로그에서

```
전제: I-01에서 추가한 "라멘 이치란" 존재
단계:
  1. "라멘 이치란" 카드 클릭 → DetailDialog 열림
  2. 이름 수정: "라멘 이치란 본점"
  3. 메모 추가: "웨이팅 30분"
  4. 저장 (다이얼로그 닫기)
검증:
  - 카드에 "라멘 이치란 본점" 표시
  - DetailDialog 재오픈 시 메모 "웨이팅 30분" 존재
  - 토스트 "이름이 변경되었습니다"
```

### I-03. 아이템 시간 변경 (카드에서)

```
전제: "라멘 이치란 본점" 12:00
단계:
  1. PlaceCard의 시간 영역 탭
  2. 시간 수정 다이얼로그 → "13:30"
  3. 저장
검증:
  - 카드 시간이 "13:30"으로 변경
  - 섹션 내 위치가 시간순에 맞게 재정렬
```

### I-04. 아이템 삭제

```
전제: 아이템 존재
단계:
  1. DetailDialog 열기 → 삭제 버튼 또는 스와이프 삭제
  2. 확인 다이얼로그 → "삭제"
검증:
  - 카드 사라짐
  - 토스트에 "복구" 액션
```

### I-05. 아이템 삭제 후 복구 (Undo)

```
전제: I-04 직후
단계:
  1. 토스트 "복구" 클릭
검증:
  - 아이템 다시 나타남
  - 내용 동일
```

### I-06. 아이템 Day 이동

```
전제: Day 1에 "라멘 이치란", Day 2 비어있음
단계:
  1. DetailDialog → "Day 이동" 또는 이동 UI
  2. Day 2 선택
검증:
  - Day 1에서 "라멘 이치란" 사라짐
  - Day 2에 "라멘 이치란" 표시
  - 토스트에 이동 확인 메시지
```

### I-07. 중복 시간 추가 경고

```
전제: Day 1에 12:00 아이템 존재
단계:
  1. AddPlacePage에서 시간 "12:00", 다른 아이템 추가
검증:
  - "12:00에 이미 일정이 있습니다" 확인 다이얼로그
  - "추가" 클릭 → 추가됨
```

### I-08. 예약 정보 붙여넣기 (PasteInfoPage)

```
전제: 여행 플래너 열림
단계:
  1. "일정 추가" → "예약 정보 붙여넣기"
  2. 예약 확인 메일 텍스트 붙여넣기:
     "Hotel Gracery Shinjuku
      チェックイン: 2026年3月1日 15:00
      チェックアウト: 2026年3月3日 11:00"
  3. AI 파싱 대기 → 결과 확인
  4. 체크박스 선택 → 추가
검증:
  - 파싱된 아이템에 호텔명, 체크인/아웃 시간 포함
  - 유형 "stay"
  - 추가 후 Day에 표시
```

---

## 4. 일괄 작업

### B-01. 일괄 삭제 모드

```
전제: Day 1에 아이템 3개 이상
단계:
  1. 일괄 삭제 버튼 클릭
  2. 아이템 2개 체크
  3. "N개 삭제" 클릭
검증:
  - 체크한 2개 아이템 삭제됨
  - 나머지 아이템 유지
```

### B-02. 일괄 삭제 — 전체 선택

```
전제: Day 1에 아이템 5개
단계:
  1. 일괄 삭제 모드 진입
  2. "전체 선택" 클릭
  3. 삭제
검증:
  - 5개 모두 삭제
  - Day가 빈 상태 (섹션만 남음)
```

### B-03. 롱프레스 다건 선택 → 삭제 (H4 수정 검증)

```
전제: Day 1에 아이템 3개
단계:
  1. 아이템 A 길게 누르기 → 선택 모드
  2. 아이템 B 탭 → 추가 선택
  3. 삭제 버튼
  4. 확인
검증:
  - A, B 삭제됨
  - C 유지
  - 토스트에 "2개 일정이 삭제되었습니다" + 복구 버튼
  - "복구" 클릭 시 A, B 복원 (undo 지원 검증)
```

### B-04. 롱프레스 다건 선택 → Day 이동 (H3 수정 검증)

```
전제: Day 1에 아이템 A, B, C / Day 2 비어있음
단계:
  1. A, B 롱프레스 선택
  2. "Day 이동" → Day 2 선택
검증:
  - Day 1에 C만 남음
  - Day 2에 A, B 추가
  - 토스트 "2개를 Day 2(으)로 이동했어요"
  - Day 2 자동 선택됨
```

### B-05. AI 일정 교체 (replace 모드)

```
전제: Day 1에 기존 아이템 존재
단계:
  1. AI 채팅 또는 bulk import에서 "교체" 모드로 실행
검증:
  - Day 1의 기존 아이템이 모두 사라지고 새 아이템으로 교체
  - _extraDays base도 동기화 (standalone 여행인 경우)
```

---

## 5. 상세 다이얼로그 (DetailDialog)

### DD-01. 기본 정보 표시

```
전제: RAG 매칭된 아이템 (예: "센소지") 존재
단계:
  1. 카드 클릭 → DetailDialog 열림
검증:
  - 3줄 헤더: 이름, 카테고리, 주소
  - 이미지 캐러셀 (1장 이상)
  - 평점 + 리뷰 수
  - 영업시간 (있으면)
  - 미니맵 표시
```

### DD-02. 주소 변경

```
단계:
  1. DetailDialog에서 주소 영역 탭
  2. 새 주소 검색/입력
  3. 저장
검증:
  - 주소 변경됨
  - 미니맵 위치 변경
  - 토스트 "주소가 변경되었습니다"
```

### DD-03. 이미지 추가/삭제

```
단계:
  1. DetailDialog에서 이미지 추가 (파일 업로드)
검증:
  - 새 이미지가 캐러셀에 표시
  - 이미지 삭제 시 _imageRemovedByUser 가드 작동
  - 삭제 후 Google Photos 자동 채우기 안 됨
```

### DD-04. Day 이동 (DetailDialog에서)

```
단계:
  1. DetailDialog 내 "Day 이동" 버튼
  2. 대상 Day 선택
검증:
  - 다이얼로그 닫힘
  - source Day에서 제거, target Day에 추가
```

### DD-05. 삭제 (DetailDialog에서)

```
단계:
  1. DetailDialog 내 삭제 버튼
  2. 확인
검증:
  - 다이얼로그 닫힘
  - 아이템 제거됨
  - 복구 가능
```

---

## 6. 동시편집 (2 브라우저)

> 모든 동시편집 테스트는 2개의 BrowserContext를 사용.
> User A = 여행 owner, User B = editor (공유 코드로 join)

### 셋업 패턴:

```javascript
// tests/concurrent.spec.js
test.describe('동시편집', () => {
  let contextA, contextB, pageA, pageB, tripId;

  test.beforeAll(async ({ browser }) => {
    contextA = await browser.newContext({ storageState: 'tests/auth/user-a.json' });
    contextB = await browser.newContext({ storageState: 'tests/auth/user-b.json' });
    pageA = await contextA.newPage();
    pageB = await contextB.newPage();

    // User A가 여행 생성
    tripId = await createTripAndGetId(pageA, '동시편집 테스트');
    // User A가 공유 코드 생성 → User B가 join
    const shareCode = await getShareCode(pageA);
    await pageB.goto(`/invite/${shareCode}`);
    await pageB.waitForURL(`/trip/${tripId}`);

    // 양쪽 다 같은 여행에 진입
    await pageA.goto(`/trip/${tripId}`);
  });
});
```

### CE-01. 기본 동기화 — 한쪽 추가, 다른 쪽 반영

```
전제: 양쪽 다 같은 여행 열림
단계:
  1. User A: Day 1에 아이템 "테스트 장소" 추가
  2. 3~5초 대기
검증:
  - User B 화면에 "테스트 장소" 자동 표시 (realtime)
  - 새로고침 없이 반영
```

### CE-02. 양쪽 동시 추가 — 다른 Day

```
단계:
  1. User A: Day 1에 "A의 장소" 추가
  2. User B: (거의 동시에) Day 2에 "B의 장소" 추가
  3. 5초 대기
검증:
  - User A: Day 1에 "A의 장소", Day 2에 "B의 장소"
  - User B: Day 1에 "A의 장소", Day 2에 "B의 장소"
  - 양쪽 동일
```

### CE-03. 양쪽 동시 추가 — 같은 Day

```
단계:
  1. User A: Day 1에 "A의 장소" 추가
  2. User B: (거의 동시에) Day 1에 "B의 장소" 추가
  3. 5초 대기 + 양쪽 새로고침
검증:
  - 양쪽 다 Day 1에 "A의 장소" + "B의 장소" 모두 존재
  - 둘 다 유실 안 됨
```

### CE-04. Day 이동 후 데이터 보존 (보고된 버그 재현 검증)

```
★ 이 테스트가 가장 중요 — 원래 보고된 버그

단계:
  1. 준비: Day 1에 아이템 A, B, C 추가
  2. User B도 같은 화면 열림 확인
  3. User A: 아이템 A를 Day 2로 이동
  4. 5초 대기
  5. User A: 새로고침
  6. User B: 새로고침
검증:
  - User A Day 1: B, C 존재 (A 없음) ★ 핵심: B, C가 살아있어야 함
  - User A Day 2: A 존재
  - User B: 동일
```

### CE-05. 한쪽 삭제, 다른 쪽 수정 (같은 아이템)

```
단계:
  1. 아이템 X 존재
  2. User A: X 삭제
  3. User B: (거의 동시에) X의 메모 수정
  4. 5초 대기 + 양쪽 새로고침
검증:
  - 아이템 X가 삭제됨 (삭제 우선) 또는
  - 수정된 X가 살아있음 (last-write-wins)
  - 어느 쪽이든 크래시 없음, 데이터 정합성 유지
```

### CE-06. 한쪽 Day 추가, 다른 쪽 반영

```
단계:
  1. User A: Day 5 추가
  2. 5초 대기
검증:
  - User B 화면에 Day 5 탭 자동 표시
```

### CE-07. 한쪽 Day 삭제, 다른 쪽 해당 Day 편집 중

```
단계:
  1. User B: Day 3의 아이템 편집 중 (DetailDialog 열림)
  2. User A: Day 3 삭제
  3. 5초 대기
검증:
  - User B: Day 3이 사라짐
  - DetailDialog가 정상적으로 닫히거나 에러 없이 처리
  - 크래시 없음
```

### CE-08. 한쪽 Day 순서 변경, 다른 쪽 반영

```
단계:
  1. User A: Day 순서를 [3,1,2,4]로 변경
  2. 5초 대기
검증:
  - User B: 동일한 순서 반영
  - 각 Day의 아이템이 올바른 Day에 표시
```

### CE-09. 삭제 복구 (Undo) 동시편집 중 (H2 수정 검증)

```
단계:
  1. User A: 아이템 삭제
  2. User B: (거의 동시에) 다른 아이템 수정
  3. User A: "복구" 클릭
  4. 5초 대기 + 양쪽 새로고침
검증:
  - User A의 삭제한 아이템 복구됨
  - User B의 수정도 유지됨
  - 데이터 충돌 없음
```

### CE-10. 다건 이동 동시편집 중 (H3 수정 검증)

```
단계:
  1. Day 1에 A, B, C, D, E
  2. User A: A, B를 롱프레스 선택 → Day 2로 이동
  3. User B: (거의 동시에) D를 수정
  4. 5초 대기 + 양쪽 새로고침
검증:
  - Day 1: C, D(수정됨), E
  - Day 2: A, B
  - 네트워크 요청이 이동 전체에 대해 1회만 (개발자 도구로 확인 가능)
```

### CE-11. version 증가 확인 (H1 수정 검증)

```
단계:
  1. User A: 아이템 추가 (저장 1회)
  2. User A: 아이템 또 추가 (저장 2회)
  3. User B: 아이템 추가 (저장 3회)
검증:
  - User A에게 User B의 변경이 정상 반영 (두 번째 이후 realtime 차단 안 됨)
  - 반복 테스트 5회 → 한 번도 realtime 누락 없음
```

---

## 7. 데이터 정합성 (CRUD 감사 리포트 항목)

> 동시편집이 아닌, 단일 사용자 CRUD 엣지케이스

### DI-01. 키 구분자 일관성 — 롱프레스 선택 후 정상 매칭 (HI-3)

```
전제: _id가 없는 레거시 아이템 (또는 _id 제거한 테스트 아이템)
단계:
  1. 아이템 롱프레스 선택
  2. 삭제
검증:
  - 선택한 아이템만 정확히 삭제 (동명 아이템이 있어도 하나만)
```

### DI-02. 삭제 가드 — 3곳 중 1곳에서만 삭제 (HI-1)

```
전제: 같은 시간+이름의 아이템이 extraItems와 _extraDays 양쪽에 있을 수 있는 상태
단계:
  1. 아이템 이동 (Day A → Day B)
검증:
  - Day A에서 아이템 정확히 1개만 제거 (복제 안 됨)
  - Day B에 1개만 추가
```

### DI-03. Bulk import 중복 체크 (HI-2)

```
전제: Day 1에 "12:00 라멘" 이미 존재
단계:
  1. AI 또는 붙여넣기로 "12:00 라멘" 포함된 결과 import (append 모드)
검증:
  - 중복 리뷰 다이얼로그 표시
  - 중복 아이템 체크/해제 가능
```

### DI-04. sanitizeScheduleData 정합성 (CR-2)

```
이 테스트는 직접 UI 테스트가 어려움 → 콘솔 로그 또는 상태 검증.

전제: standalone 여행 (baseLen === 0)
단계:
  1. 아이템 여러 개 추가
  2. 일부 삭제
  3. 새로고침
검증:
  - 삭제한 아이템이 부활하지 않음
  - 남은 아이템이 정확함
  - console.error 없음
```

### DI-05. _dayOrder 범위 검증 (MD-3)

```
전제: Day 순서 변경한 상태 + Day 삭제 후 복구
단계:
  1. Day 순서 [2,0,1,3] 설정
  2. Day 삭제 (원래 0번)
  3. "복구" 클릭
  4. 새로고침
검증:
  - Day 순서가 정상 유지
  - out-of-range 인덱스로 인한 undefined Day 없음
  - 렌더링 정상
```

### DI-06. 연속 삭제 후 복구 (HI-5)

```
전제: 아이템 A, B, C 존재
단계:
  1. A 삭제
  2. B 삭제
  3. "복구" 클릭
검증:
  - B만 복구됨 (단일 스냅샷이므로)
  - A는 복구 안 됨
  - 명확한 기대 동작 확인 (현재 설계의 한계 인지)
```

---

## 8. 새로고침 후 데이터 지속성

### R-01. 모든 CRUD 후 새로고침

```
단계:
  1. 아이템 추가
  2. 아이템 수정
  3. Day 추가
  4. Day 이름 변경
  5. Day 순서 변경
  6. 새로고침 (F5)
검증:
  - 모든 변경사항 유지
  - console.error 없음
```

### R-02. 네트워크 끊김 시뮬레이션 후 재연결

```
단계:
  1. 아이템 추가 (정상 저장)
  2. 네트워크 오프라인 (page.route으로 차단)
  3. 아이템 추가 시도
  4. 네트워크 복구
  5. 새로고침
검증:
  - 오프라인 중 추가한 아이템의 처리 확인
  - 토스트에 저장 실패 메시지
  - 재연결 후 정상 동작
```

---

## 9. 엣지케이스 & 스트레스

### E-01. 빈 여행에서 모든 작업

```
전제: 아이템 0개, Day 1만 있는 빈 여행
단계:
  1. Day 추가/삭제/이름변경
  2. 아이템 추가/삭제
  3. 일괄 삭제 모드 진입
검증:
  - 모든 작업이 에러 없이 동작
  - 빈 상태 UI 정상 표시
```

### E-02. 긴 일정 (Day 10+)

```
단계:
  1. Day 10개 추가
  2. 각 Day에 아이템 5개씩 추가
  3. Day 순서 변경
  4. 아이템 Day 이동 (Day 1 → Day 10)
  5. 새로고침
검증:
  - 모든 데이터 유지
  - Day 탭 스크롤 정상
  - 성능 이상 없음 (5초 이내 로딩)
```

### E-03. 특수문자 아이템명

```
단계:
  1. 아이템 추가: 이름 "カフェ「珈琲屋」(東京) ★★★"
  2. 저장
  3. 새로고침
검증:
  - 특수문자 그대로 표시
  - 검색/매칭 시 깨지지 않음
```

### E-04. 동시편집 — 빠른 연속 작업

```
단계:
  1. User A: 0.5초 간격으로 아이템 5개 연속 추가
  2. User B: 동시에 0.5초 간격으로 다른 Day에 아이템 5개 추가
  3. 10초 대기 + 양쪽 새로고침
검증:
  - 양쪽 다 10개 아이템 모두 존재
  - 유실 없음
```

---

## 테스트 실행 가이드

### 실행 순서 (추천)

```
Phase 1 (기본 플로우):     T-01 → D-01~02 → I-01~06 → R-01
Phase 2 (일괄/엣지):       B-01~04 → DD-01~05 → E-01~03
Phase 3 (동시편집):         CE-01~04 → CE-09~11
Phase 4 (데이터 정합성):    DI-01~06 → CE-05~08 → E-04
Phase 5 (스트레스):         E-02 → E-04 → R-02
```

### timeout 설정

| 카테고리 | 기본 timeout | 비고 |
|----------|-------------|------|
| UI 조작 | 5s | 클릭, 입력 |
| Realtime 동기화 | 8s | 상대방 반영 대기 |
| AI 생성 | 150s | Gemini API 호출 (2박3일 기준 ~2분) |
| 새로고침 후 로드 | 10s | Supabase 쿼리 |
| 네트워크 복구 | 15s | 재연결 |

### 주의사항

1. **인증 세션 만료**: storageState의 토큰 유효기간 확인. 만료 시 수동 재로그인 후 재저장.
2. **API 비용**: T-02 (AI 생성) 테스트는 Gemini API 호출 → 비용 발생. 반복 실행 주의.
3. **Rate Limit**: Google Places API 테스트 시 rate limit 고려.
4. **테스트 격리**: 각 테스트 스위트가 고유 여행을 만들고 정리해야 다른 테스트에 영향 없음.
5. **동시편집 타이밍**: `page.waitForTimeout()` 대신 `page.waitForSelector()` 또는 polling으로 반영 대기.
